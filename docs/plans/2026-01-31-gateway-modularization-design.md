# 网关模块化（渐进式拆分）设计稿

> 主题：将 `backend/src/promptxy/gateway.ts` 渐进式拆分为可测试、可演进的业务语义模块（Routing / Transform / Proxying / Streaming），在保持外部行为不变的前提下显著提升可维护性。

## 1. 背景与动机

当前网关核心逻辑高度集中在单一文件中（`gateway.ts`），包含：本地服务识别、路由决策、协议转换推导、上游请求转发、SSE/流式写回、静态资源/辅助处理等多种职责。

这种结构在迭代中会带来典型问题：
- 变更影响面过大，回归风险高
- 失败路径难以统一处理（转换失败 / 上游异常 / SSE 中断等）
- 难以做隔离测试，导致质量更多依赖端到端冒烟
- 扩展新 supplier/protocol 时，容易被迫修改核心网关逻辑

本设计目标是“结构清晰化与边界显式化”，而非功能重写。

## 2. 目标 / 非目标

### 2.1 目标
- 在不改变外部接口与行为的前提下，将网关拆分为职责单一的模块
- 建立显式的核心契约（`RequestContext` / `RoutePlan` 等），减少隐式上下文依赖
- 统一错误模型，使失败路径可预测、可观测，尤其保证 SSE/流式场景正确结束
- 提升可测试性：优先让 `Routing` 具备可单测能力，其它模块逐步覆盖
- 让新增 supplier/protocol 的改动尽量局限在 `Transform` 与 `Proxying` 实现

### 2.2 非目标
- 不引入新的客户端协议支持（遵循项目决策：转换器只需支持 `/claude -> 任意供应商`）
- 不进行“重写网关”或大范围行为变更
- 不在本轮强行优化所有性能问题（可在边界稳定后再做）

## 3. 方案选型（含取舍）

### 方案 A（推荐）：渐进式“边界清晰化 + 模块抽取”
- 特征：保持外部行为不变，先抽契约与薄层适配，再逐步迁移实现
- 优点：风险最低、可回滚、可逐步验证；适合当前项目快速迭代节奏
- 缺点：短期存在“旧代码+新模块”并存，需要阶段性结构约束

### 方案 B：以“路由/协议”为中心的分层重构
- 特征：强制形成 `Context -> Plan -> Execute -> Stream` 分层，允许小范围签名调整
- 优点：结构最干净，长期收益高
- 缺点：触及面更大，若测试护栏不足更易回归

### 方案 C：最小改动“抽接口 + 测试护栏”
- 特征：优先抽接口与补测试，拆文件推后
- 优点：最快建立质量护栏
- 缺点：若不继续推进拆分，复杂度不会真正下降

结论：采用 **方案 A**，并在 A 的第一个迭代引入 C 的“测试护栏”思路（先契约+单测，再迁移实现）。

## 4. 目标架构与模块边界（业务语义）

拆分为四个业务语义模块：

1) **Routing**
- 输入：`RequestContext`
- 输出：`RoutePlan`
- 职责：识别本地服务（以 `/claude` 为主）、解析模型映射/规则、选择 supplier/protocol、决定是否需要 Transform、生成关键策略位
- 禁止：任何网络 I/O

2) **Transform**
- 输入：`RequestContext` + `RoutePlan`
- 输出：`UpstreamPlan`（上游请求形状 + 回写策略抽象）或可归一错误
- 职责：决定 transformer 类型；将“本地（Claude）请求/响应事件”映射为“上游协议请求/响应事件”

3) **Proxying**
- 输入：`UpstreamPlan`
- 输出：上游响应事件流 / 结构化错误
- 职责：构造并发送上游请求，处理超时/重试边界（若已有则保持一致），把上游错误归一

4) **Streaming**
- 输入：上游响应事件流 / 错误
- 输出：对客户端的 SSE/HTTP 写回
- 职责：维护流生命周期（start/end/abort），保证流式场景“确定性结束”，避免客户端挂起

模块之间只通过显式结构传递，不共享内部状态。

## 5. 核心契约（数据结构）

### 5.1 `RequestContext`（只读事实）
建议包含（按最小可用原则逐步补齐）：
- 原始请求对象与 headers（原封不动保存，必要时再读取）
- 解析后的路径信息（本地服务标识，如 `/claude`）
- 请求体的“最小必要摘要”（例如：model、stream 标记、消息类型）
- 追踪字段：`requestId` / `sessionId`（若现有系统已有生成/提取逻辑，则复用）

原则：避免过早把协议细节塞进 Context，优先放“路由决策必需信息”。

### 5.2 `RoutePlan`（路由决策结果）
建议包含：
- 选中的 supplier、上游协议类型（supplierProtocol）、目标模型
- 是否需要 Transform、选择哪种 transformer
- 关键策略位：是否允许直通、是否强制流式、限制项来源（配置/规则/默认）

### 5.3 `UpstreamPlan`（执行计划）
建议包含：
- 上游请求的规范化描述（method/url/headers/body/stream 语义）
- 回写策略（Streaming 所需的协议封装/事件映射信息）

## 6. 错误模型与可观测性

### 6.1 统一错误模型
建议内部统一为 `GatewayError`（或等价结构），字段建议：
- `category`: `Routing | Transform | Proxying | Streaming`
- `code`: 稳定枚举（便于统计与兼容）
- `httpStatus`: 对非流式响应的状态码
- `isRetryable`: 是否可重试（仅供内部策略/日志）
- `safeMessage`: 可对客户端展示的简要信息
- `debug`: 仅日志使用的调试信息（含堆栈/上游响应片段等）

关键约束：
- 任意模块抛出的错误必须可被 `Streaming` 接住并做“确定性收尾”（流式结束/连接关闭/终止事件）

### 6.2 可观测性点位（边界事件）
建议把日志/指标固定在边界处：
- `Routing`: route 选择（supplier/protocol/model/是否 transform）
- `Transform`: transformer 类型与转换失败原因
- `Proxying`: 上游耗时/状态码/重试次数
- `Streaming`: 流 start/end/abort 与写回异常

验收标准之一：能用 records-query 以同一 `requestId` 串起上述边界事件。

## 7. 渐进式落地路线图（建议顺序）

### 阶段 1：抽出 Routing（优先）
- 动作：将路由决策的纯逻辑集中到 `routing/`（目录/命名可按现有结构确定）
- 测试：新增单测只覆盖 `Routing`（不做网络）
- 验收：同一批请求样例得到一致的 `RoutePlan`

### 阶段 2：抽出 Transform
- 动作：把 claude -> supplier 的转换逻辑迁移到 `transform/`
- 验收：生成的上游请求关键字段与现状一致；转换失败能正确、稳定地结束流

### 阶段 3：抽出 Proxying
- 动作：上游请求发送与错误归一迁移到 `proxying/`
- 验收：上游错误分类稳定；响应码与 body 不回归

### 阶段 4：抽出 Streaming
- 动作：统一 SSE 生命周期与写回异常处理到 `streaming/`
- 验收：不再出现“流式挂住不结束”；abort 场景可定位

## 8. 风险与回滚策略

- 风险：在“旧代码+新模块”并存阶段容易形成新的耦合
  - 缓解：每个阶段只迁移一个清晰边界，避免跨模块互相调用内部细节
- 风险：流式边界语义最容易出现隐性回归
  - 缓解：优先补充针对 SSE 生命周期的集成测试/脚本化验证（按项目现有测试体系选择）
- 回滚：每个阶段保持外部行为不变；若出现回归，可在入口处切回旧路径（短期）

---

## 9. 附：本设计的成功判据（最小集合）
- `gateway.ts` 的职责被明确分割，后续新增 supplier/protocol 不再需要频繁触碰核心路由逻辑
- `Routing` 具备可单测能力，并成为路由行为稳定性的护栏
- 任何失败路径都能产生“可定位 + 可结束”的响应（尤其是 SSE 场景）
