## Context

当前系统使用 sql.js (SQLite 的 WebAssembly 版本) 存储请求记录，遇到严重的数据库损坏问题：

1. **数据损坏频繁**：sql.js 是内存数据库，每次写入需要 export 整个数据库到文件，程序异常退出时容易导致数据库文件损坏
2. **单点故障**：整个数据库在一个文件中，损坏后所有数据丢失
3. **写入效率低**：每次写入都需要 export 完整数据库
4. **调试困难**：数据库文件是二进制格式，无法直接查看

### 约束条件
- 预期数据量：1000 条记录
- 每条请求大小：可达 300KB 以上
- 查询频率：约 10 秒/次（较低）
- 性能要求：越快越好
- 不需要迁移旧数据

### 涉及系统
- 请求记录存储系统
- API 查询接口
- 网关请求记录逻辑

## Goals / Non-Goals

### Goals
1. **数据可靠性**：单个文件损坏不影响整体数据
2. **写入原子性**：每次写入是原子操作
3. **查询性能**：列表查询响应时间 < 100ms
4. **内存效率**：内存占用 < 100MB
5. **易于调试**：文件格式人类可读（YAML）
6. **ID 可读性**：请求 ID 包含时间信息，便于排序和定位

### Non-Goals
1. 不支持复杂 SQL 查询（使用简单的内存过滤）
2. 不支持事务（文件系统级别）
3. 不支持高并发写入（单进程场景）
4. **不迁移旧数据**：直接废弃 SQLite
5. **无回退计划**：破坏性变更，简化代码库

## Decisions

### Decision 1: 索引 + 按需加载架构

**选择**：内存中只保留轻量级索引，详情文件按需加载

**理由**：
- 1000 条 × 300KB = 300MB，无法全部加载到内存
- 索引只包含查询必要字段（id, timestamp, client, path, status, duration），约 60 字节/条
- 1000 条索引约 60KB，完全可放入内存
- 详情文件按需加载，使用 LRU 缓存最近访问的 50 条

**替代方案考虑**：
- 全部加载到内存：内存占用过高（300MB+）
- 纯文件系统无缓存：每次查询详情都要读文件，性能差

### Decision 2: YAML 格式存储

**选择**：使用 YAML 格式存储请求详情

**理由**：
- 多行字符串用 `|` 表示，不需要转义
- 对 JSON 数据友好，请求体直接嵌入
- 人类可读，便于调试
- js-yaml 库成熟稳定

**替代方案考虑**：
- JSON：需要大量转义，可读性差
- 二进制格式：不可读，调试困难

### Decision 3: 请求 ID 格式

**选择**：`YYYY-MM-DD_HH-mm-ss-SSS_random` 格式

**示例**：`2025-01-15_14-30-25-123_a1b2c3`

**理由**：
- 与前端显示格式一致（`formatTimeWithMs`）
- 文件名即时间，直接浏览 requests/ 目录即可按时间排序
- 使用 `-` 分隔而非 `:`，避免 Windows 文件系统问题
- 6位随机字符避免冲突

**替代方案考虑**：
- UUID：不可读，无法从 ID 知道时间
- 纯时间戳：可读性差，可能冲突

### Decision 4: 索引文件格式

**选择**：管道符分隔的纯文本格式

**格式**：`timestamp|id|client|path|method|reqSize|respSize|status|duration|error|rules`

**理由**：
- 简单、易解析、可读
- 启动时逐行读取，内存占用低
- 便于手动检查和调试

**替代方案考虑**：
- JSON：需要解析整个文件
- 二进制格式：不可读

### Decision 5: LRU 缓存

**选择**：缓存最近访问的 50 个详情文件

**理由**：
- 用户通常会反复查看最近的请求
- 50 × 300KB = 15MB，内存占用可接受
- LUR 自动淘汰最久未使用的数据

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         内存层 (约5MB)                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │ 时间索引数组 │  │ 路径缓存Set │  │ LRU详情缓存 (约50条)   │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↕ 按需加载
┌─────────────────────────────────────────────────────────────────┐
│                         文件层                                   │
│  ┌──────────────┐  ┌──────────────────────────────────────┐    │
│  │ 索引文件      │  │ 请求文件 requests/{id}.yaml          │    │
│  │ timestamp.idx│  │ (YAML格式，完整的请求体数据)          │    │
│  └──────────────┘  └──────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 内存索引结构
```typescript
interface RequestIndex {
  id: string;              // 2025-01-15_14-30-25-123_a1b2c3
  timestamp: number;       // 1736898625123 (用于数值排序)
  client: string;
  path: string;
  method: string;
  requestSize?: number;
  responseSize?: number;
  responseStatus?: number;
  durationMs?: number;
  error?: string;
  matchedRulesBrief: string[];
}
```

### 请求文件格式
```yaml
id: 2025-01-15_14-30-25-123_a1b2c3
timestamp: 1736898625123
client: claude
path: /v1/messages
method: POST
requestSize: 1024
responseSize: 2048
matchedRules:
  - ruleId: rule-001
    opType: set
responseStatus: 200
durationMs: 1234
responseHeaders:
  content-type: application/json
originalBody: |
  {
    "model": "claude-3-5-sonnet-20241022",
    "messages": [...]
  }
modifiedBody: |
  {...}
responseBody: |
  {...}
error: null
```

## Risks / Trade-offs

### 风险 1: 大量小文件性能
**风险**：1000 个小文件可能影响文件系统性能
**缓解**：
- 使用单层目录结构（requests/），不使用时间分区
- 现代文件系统对单目录 1000 个文件性能良好

### 风险 2: 并发写入
**风险**：多个请求同时写入可能导致索引文件冲突
**缓解**：
- 使用文件锁保护索引写入
- 先写请求文件，再更新索引
- 索引损坏可从 requests/ 目录重建

### 风险 3: 索引不一致
**风险**：程序崩溃可能导致索引文件与实际文件不一致
**缓解**：
- 启动时检测索引一致性
- 提供重建索引功能
- 请求文件是真实数据源

## Implementation Plan

### 步骤

1. **移除 sql.js 依赖**
   ```bash
   npm uninstall sql.js
   npm install js-yaml
   npm install -D @types/js-yaml
   ```

2. **重写 database.ts**
   - 实现 `FileSystemStorage` 类
   - 保持所有导出函数签名不变
   - 初始化时加载索引到内存

3. **更新启动流程**
   - `main.ts` 和 `cli-entry.ts` 无需修改
   - `initializeDatabase()` 改为初始化文件系统存储
   - 旧的 `promptxy.db` 文件自然保留，不做处理

4. **代码清理**
   - 确保所有 sql.js 相关代码被移除
   - 确保没有遗留的导入语句

## Open Questions

无
